import React, { useState, useCallback, useEffect } from 'react'
import { ProposalConfirmation } from '../viewers/ProposalConfirmation'
import { PDFViewer } from '../viewers/PDFViewer'
import ValidationPanel from '../validation/ValidationPanel'
import { proposalStorage } from '../../../lib/pdf/services/storage'
import { 
  ProposalData, 
  ClientData, 
  SavedProposal
} from '../../../lib/types/pdf/core'
import {
  PDFError,
  PDFErrorType 
} from '../../../lib/types/pdf/errors'
import { 
  generatePDFFileName,
  downloadPDF,
  openPDFInNewTab,
  revokePDFBlobUrl,
  validatePDFBlob
} from '../../../lib/pdf/utils/pdf-viewer'
import { 
  validateAdvanced, 
  applyAutoFixes, 
  ValidationReport 
} from '../../../lib/pdf/utils/advanced-validation'
import { useToast } from '../../../hooks/use-toast'

interface ProposalPDFManagerProps {
  isConfirmationOpen: boolean
  onCloseConfirmation: () => void
  onEditProposal: (proposalId?: string) => void
  proposalData: ProposalData
  clientData: ClientData
  pdfBlob: Blob
  pdfUrl: string
  proposalId?: string // For editing existing proposals
  onDataUpdated?: (proposalData: ProposalData, clientData: ClientData) => void // For applying fixes
}

export function ProposalPDFManager({
  isConfirmationOpen,
  onCloseConfirmation,
  onEditProposal,
  proposalData,
  clientData,
  pdfBlob,
  pdfUrl,
  proposalId,
  onDataUpdated
}: ProposalPDFManagerProps) {
  const [isViewerOpen, setIsViewerOpen] = useState(false)
  const [isSaving, setIsSaving] = useState(false)
  const [savedProposalId, setSavedProposalId] = useState<string | null>(null)
  const [validationReport, setValidationReport] = useState<ValidationReport | null>(null)
  const [showValidation, setShowValidation] = useState(false)
  const { toast } = useToast()

  // Generate filename for downloads
  const fileName = generatePDFFileName(clientData.companyName, clientData.projectName)

  // Run validation when data changes
  useEffect(() => {
    const report = validateAdvanced(proposalData, clientData)
    setValidationReport(report)
    
    // Show validation panel if there are issues
    if (!report.valid || report.warnings.length > 0 || report.infos.length > 0) {
      setShowValidation(true)
    }
  }, [proposalData, clientData])

  // Save proposal to storage
  const saveProposal = useCallback(async (): Promise<string | null> => {
    if (savedProposalId) {
      return savedProposalId // Already saved
    }

    if (!validatePDFBlob(pdfBlob)) {
      toast({
        title: "Erro de Validação",
        description: "O PDF gerado não é válido.",
        variant: "destructive"
      })
      return null
    }

    setIsSaving(true)
    
    try {
      const proposal: SavedProposal = {
        id: '', // Will be generated by storage
        clientName: clientData.companyName,
        projectName: clientData.projectName,
        totalValue: proposalData.totalMonthly,
        createdAt: new Date(),
        updatedAt: new Date(),
        pdfBlob,
        proposalData,
        clientData,
        version: 1
      }

      const proposalId = await proposalStorage.save(proposal)
      setSavedProposalId(proposalId)
      
      toast({
        title: "Proposta Salva",
        description: "A proposta foi salva com sucesso no sistema.",
      })
      
      return proposalId
    } catch (error) {
      console.error('Failed to save proposal:', error)
      toast({
        title: "Erro ao Salvar",
        description: "Não foi possível salvar a proposta. Tente novamente.",
        variant: "destructive"
      })
      return null
    } finally {
      setIsSaving(false)
    }
  }, [pdfBlob, proposalData, clientData, savedProposalId, toast])

  // Enhanced save with validation
  const saveProposalWithValidation = useCallback(async (): Promise<string | null> => {
    // Check for blocking validation errors
    if (validationReport && !validationReport.valid) {
      toast({
        title: "Validação Necessária",
        description: "Corrija os erros de validação antes de salvar a proposta.",
        variant: "destructive"
      })
      setShowValidation(true)
      return null
    }

    return await saveProposal()
  }, [validationReport, saveProposal, toast])

  // Handle PDF viewing
  const handleViewPDF = useCallback(async () => {
    try {
      // Save proposal first if not already saved (with validation)
      const proposalId = await saveProposalWithValidation()
      if (!proposalId) return // Validation failed
      
      setIsViewerOpen(true)
    } catch (error) {
      console.error('Failed to open PDF viewer:', error)
      toast({
        title: "Erro de Visualização",
        description: "Não foi possível abrir o visualizador de PDF.",
        variant: "destructive"
      })
    }
  }, [saveProposalWithValidation, toast])

  // Handle PDF download
  const handleDownloadPDF = useCallback(async () => {
    try {
      // Save proposal first if not already saved (with validation)
      const proposalId = await saveProposalWithValidation()
      if (!proposalId) return // Validation failed
      
      downloadPDF(pdfUrl, fileName)
      
      toast({
        title: "Download Iniciado",
        description: `O arquivo ${fileName} está sendo baixado.`,
      })
    } catch (error) {
      console.error('Failed to download PDF:', error)
      toast({
        title: "Erro no Download",
        description: "Não foi possível fazer o download do PDF.",
        variant: "destructive"
      })
    }
  }, [pdfUrl, fileName, saveProposalWithValidation, toast])

  // Handle opening PDF in new tab
  const handleOpenInNewTab = useCallback(() => {
    try {
      openPDFInNewTab(pdfUrl, fileName)
    } catch (error) {
      console.error('Failed to open PDF in new tab:', error)
      toast({
        title: "Erro",
        description: "Não foi possível abrir o PDF em nova aba.",
        variant: "destructive"
      })
    }
  }, [pdfUrl, fileName, toast])

  // Handle edit proposal
  const handleEditProposal = useCallback(async () => {
    try {
      // Save proposal first if not already saved (allow editing even with validation issues)
      const currentProposalId = await saveProposal()
      
      // Close confirmation dialog
      onCloseConfirmation()
      
      // Call parent edit handler with proposal ID
      onEditProposal(currentProposalId || proposalId)
    } catch (error) {
      console.error('Failed to prepare proposal for editing:', error)
      // Still allow editing even if save fails
      onCloseConfirmation()
      onEditProposal(proposalId)
    }
  }, [saveProposal, onCloseConfirmation, onEditProposal, proposalId])

  // Handle confirmation close
  const handleCloseConfirmation = useCallback(() => {
    // Save proposal when closing confirmation (background save)
    saveProposal().catch(console.error)
    onCloseConfirmation()
  }, [saveProposal, onCloseConfirmation])

  // Handle viewer close
  const handleCloseViewer = useCallback(() => {
    setIsViewerOpen(false)
  }, [])

  // Handle applying automatic fixes
  const handleApplyFixes = useCallback(() => {
    if (!validationReport || !onDataUpdated) return

    try {
      const { proposalData: fixedProposalData, clientData: fixedClientData, appliedFixes } = 
        applyAutoFixes(proposalData, clientData)

      // Update parent component with fixed data
      onDataUpdated(fixedProposalData, fixedClientData)

      toast({
        title: "Correções Aplicadas",
        description: `${appliedFixes.length} correção(ões) aplicada(s) automaticamente.`,
      })

      // Re-run validation
      const newReport = validateAdvanced(fixedProposalData, fixedClientData)
      setValidationReport(newReport)

    } catch (error) {
      console.error('Failed to apply fixes:', error)
      toast({
        title: "Erro nas Correções",
        description: "Não foi possível aplicar as correções automáticas.",
        variant: "destructive"
      })
    }
  }, [validationReport, proposalData, clientData, onDataUpdated, toast])

  // Handle dismissing validation panel
  const handleDismissValidation = useCallback(() => {
    setShowValidation(false)
  }, [])

  return (
    <>
      {/* Validation Panel */}
      {showValidation && validationReport && (
        <div className="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 p-4">
          <div className="bg-white rounded-lg shadow-xl max-w-2xl w-full max-h-[80vh] overflow-y-auto">
            <ValidationPanel
              report={validationReport}
              onApplyFixes={validationReport.canAutoFix ? handleApplyFixes : undefined}
              onDismiss={handleDismissValidation}
              className="m-0"
            />
          </div>
        </div>
      )}

      {/* Confirmation Dialog */}
      <ProposalConfirmation
        isOpen={isConfirmationOpen}
        onClose={handleCloseConfirmation}
        onViewPDF={handleViewPDF}
        onDownloadPDF={handleDownloadPDF}
        onEditProposal={handleEditProposal}
        proposalData={proposalData}
        clientData={clientData}
        pdfUrl={pdfUrl}
      />

      {/* PDF Viewer Dialog */}
      <PDFViewer
        isOpen={isViewerOpen}
        onClose={handleCloseViewer}
        pdfUrl={pdfUrl}
        fileName={fileName}
        onDownload={handleDownloadPDF}
      />
    </>
  )
}

export default ProposalPDFManager